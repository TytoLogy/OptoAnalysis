function varargout = plotFRA(FRA, varargin)
%------------------------------------------------------------------------
% [H, PH, WH, plotdata] = plotFRA(FRA, varargin)
%------------------------------------------------------------------------
% TytoLogy:Experiments:OptoAnalysis
%------------------------------------------------------------------------
% Plots data in FRA struct generated by computeFRA() function
%------------------------------------------------------------------------
%  Input Args:
%	 FRA			FRA data struct, usually generated by computeFRA()
%	
%	Without any options, plotFRA will plot FRA data as a pseudocolor 
%	"checkerboard" in subplot(1) and as a waterfall plot in subplot(2).
%
%	Options:
% 		'BOTH'			default plot as checkerboard and waterfall
% 		'CHECKER'		checkerboard plot
% 		'WATERFALL'		waterfall plot
%		'LOG_FREQ'		log scale frequency axis (default)
%		'LIN_FREQ'		linear scale frequency axis
%		'DB_ATTEN'		stimulus level in dB attenuation units (default)
%		'DB_SPL'			stimulus level in dB SPL
%		'FIG_H', <handle>			draw in specified figure handle
%     'AX_H', <handles>       draw in specified axes
%                         *** must be 2x1 array of axes handles
%                             handles(1) for FRA, handles(2) for waterfall
%     'INTERP', <npts>    interpolate to smooth plot
%                          if no value given, default of 100 is used
%                         Data will be interpolated across frequencies at
%                         each level using makima() interpolation method
%                         (Modified Akima piecewise cubic Hermite 
%                         interpolation.)
%     'DRAW_MESH', <true|false>    draw mesh between boxes in FRA "heat"
%                                  plot.  default is "true"
%     'PADLEVEL', <level value>    add "dummy" row of levels to ensure
%                                  checker plot shows highest level
%     'PADFREQ', <freq value>      add "dummy" row of frequencies to 
%                                  ensure checker plot shows highest 
%                                  frequency 
%
%  Output Args:
%	 H		handle to figure
%   PH   handles to [pcolor() surface;  pcolor() axes (subplot(211))]
%   WH   handles to [waterfall() patch; waterfall() axes (subplot(212))]
%   plotdata  {xdata, ydata, zdata}
%------------------------------------------------------------------------
% See Also: computeFRA, optoproc
%------------------------------------------------------------------------

%------------------------------------------------------------------------
%  Sharad Shanbhag
%   sshanbhag@neomed.edu
%------------------------------------------------------------------------
% Created: ???
%
% Revisions:
%	27 Mar 2019 (SJS): added comments, input options
%  4 Oct 2020 (SJS): added return handles
%  16 Mar 2022 (SJS): added interpolation, mesh option
%  19 Mar 2022 (SJS): added axes handles input
%  20 Mar 2023 (SJS): 
%       because of the way surfaces are drawn, the checkerboard 
%       plot doesn't draw patches for the last level row and
%       frequency column. One way to fix:
%       - adding the 'PADLEVEL' and 'PADFREQ' options that
%         will add specified level and freq to FRA.Levels, and FRA.Freqs
%         and repeat the last row and column of MeanCount:
%         these are added to xdata, ydata, zdata
%       - caller has to provide the value for pad level and pad freq, 
%         since these are case-specific
%       - internal function should be written to modularize padding (done)
%  21 Mar 2023: some cleaning up, simplifying. also fixing some tick
%               and layout things
%------------------------------------------------------------------------

%------------------------------------------------
% defaults
%------------------------------------------------
plotType = 'BOTH';
xStr = 'Frequency (kHz)';
xUnits = 'LOG';
yStr = 'Attenuation (dB)';	
yAtten = 1;
interpolateData = false;
interpolateN = 100;
drawMesh = true;
padLevel = false; %#ok<NASGU>
padLevelVal = [];
padFreq = false; %#ok<NASGU>
padFreqVal = [];

%------------------------------------------------
% initialize placeholders for graphics handles
%------------------------------------------------
% figure handle
figH = [];
% axes handles
axH = [];
% output plot handles
PH = [];    % FRA pcolor() surface handle and axes
WH = [];    % FRA waterfall() patch handle and axes

%------------------------------------------------
% process inputs
%------------------------------------------------
if nargin > 0
   n = 1;
   while n <= length(varargin)
      switch	upper(varargin{n})
         % plot type?
         case {'BOTH', 'CHECKER', 'WATERFALL'}
            plotType = upper(varargin{n});
            n = n + 1;
         % log frequency scale
         case {'LOG_FREQ', 'LOGF', 'LOG'}
            xUnits = 'LOG';
            n = n + 1;
         % linear freq scale
         case {'LIN_FREQ', 'LINF', 'LIN'}
            xUnits = 'LIN';
            n = n + 1;
         % y axis is in units of dB attenuation
         case {'DB_ATTEN', 'ATTEN'}
            yStr = 'Attenuation (dB)';
            yAtten = 1;
            n = n + 1;
         % yaxis is in units of dB SPL
         case {'DB_SPL', 'DB'}
            yStr = 'dB SPL';
            yAtten = 0;
            n = n + 1;
         % use specified figure?
         case {'FIG_H'}
            figH = varargin{n+1};
            n = n + 2;
         % use specified axes?
         case {'AX_H'}
            axH = varargin{n+1};
            n = n + 2;
         % interpolate data?
         case {'INTERP', 'INTERPOLATE'}
            interpolateData = true;
            if (n < length(varargin)) && isnumeric(varargin{n+1})
               interpolateN = varargin{n+1};
               n = n+2;
            else
               n = n+1;
            end
         % draw mesh grid around color patches?
         case {'DRAW_MESH'}
            if islogical(varargin{n+1})
               drawMesh = varargin{n+1};
               n = n+ 2;
            else
               error('%s: input error for DRAW_MESH option', mfilename);
            end
         % pad levels to have checker plot draw patches for all levels?
         case {'PADLEVEL'}
            padLevel = true; %#ok<NASGU>
            padLevelVal = varargin{n+1};
            n = n+2;
         % pad frequencies to have checker plot draw patches 
         % for all frequencies?
         case {'PADFREQ'}
            padFreq = true; %#ok<NASGU>
            padFreqVal = varargin{n+1};
            n = n+2;
            
         otherwise
            error('plotFRA: invalid option %s', varargin{n});
      end
   end
end


%------------------------------------------------------------------------
% preparatory things
%------------------------------------------------------------------------
% create or set figure
if isempty(figH) && isempty(axH)
   % if no figure or axes provided, create a figure
   figH = figure;
elseif isempty(figH) && ~isempty(axH)
   % if no figure and axes provided, use parent as figure
   figH = get(axH(1), 'Parent');
   % make current
   figure(figH);
else
   % make provided figure current
   figH = figure(figH);
end

% create or set axes
if isempty(axH)
   if strcmpi(plotType, 'BOTH')
      % if both plots to be drawn, create subplots
      % create subplots
      figure(figH);
      axH(1) = subplot(211);
      axH(2) = subplot(212);
      axes(axH(1));
   else
      % create single axes in current figure
      axH = axes(figH);
   end
else
   % try setting each axes as current just to check
   if strcmpi(plotType, 'CHECKER')
      axes(axH(1));
   elseif strcmpi(plotType, 'WATERFALL')
      axes(axH(1));
   elseif strcmpi(plotType, 'BOTH')
        axes(axH(2));
        axes(axH(1));
   else
      error('Unknown options %s', plotType)
   end
end

%------------------------------------------------------------------------
% 20 March 202: new method for creating data vectors 
% this is to deal with the different padding and interpolation options
%------------------------------------------------------------------------
[xdata, ydata, zdata] = generate_xyzdata(FRA, padFreqVal, padLevelVal, ...
                               interpolateData, interpolateN);

%------------------------------------------------
% log or lin freq?
%------------------------------------------------
if strcmpi(xUnits, 'LOG')
   xdata = log10(xdata);
end

%------------------------------------------------
% need to flip sorted atten to get
% higher atten (lower amplitude tones) at bottom of plot and
% lower atten (higher amp) at top, per FRA plot convention
% the y axis labels will be in reverse order, but we'll take care
% of that later
%------------------------------------------------
if yAtten
   ydata = fliplr(ydata);
end

%------------------------------------------------------------------------
%------------------------------------------------------------------------
% plot as color patch
%------------------------------------------------------------------------
%------------------------------------------------------------------------
if any(strcmpi(plotType, {'CHECKER', 'BOTH'}))
   PH = gobjects(2, 1);
   % draw pseudocolor checkerboard using pcolor (generates surface object)
   PH(1) = pcolor(axH(1), xdata, ydata, zdata);
   PH(2) = axH(1);
   
   % show color legend
   cH = colorbar(PH(2));
   % deal with labels and title
   xlabel(PH(2), xStr);
   ylabel(PH(2), yStr);
   title(PH(2), ...
               {	FRA.fname, ...
               sprintf('Avg Spike Count, [%d-%d] ms window', ...
                                    FRA.window(1), FRA.window(2)), ...
            }, ...
            'Interpreter', 'none');
   % re-do X tick labels to that they're more readable
   xtl = get_lin_or_log_xlabel(get(PH(2), 'XTick'), xUnits);
   set(PH(2), 'XTickLabel', xtl);
   % correct the Y tick labels, as promised
   if yAtten
      set(PH(2), 'YTickLabel', flipud(get(gca, 'YTickLabel')));
   end
   % if drawMesh is false, set the surface edge color to 'none'
   if ~drawMesh
      set(PH(1), 'EdgeColor', 'none')
   end
   % turn off box, tickdir out
   PH(2).TickDir = 'out';
   PH(2).Box = 'off';
   % change colorbar ticks
   cH.TickDirection = 'out';
end

%------------------------------------------------------------------------
%------------------------------------------------------------------------
% create subplot and plot waterfall 
% (in fashion similar to color patch)
%------------------------------------------------------------------------
%------------------------------------------------------------------------
if any(strcmpi(plotType, {'WATERFALL', 'BOTH'}))
   WH = gobjects(2, 1);
   if strcmpi(plotType, 'BOTH')
      WH(1) = waterfall(axH(2), xdata, ydata, zdata);
      WH(2) = axH(2);
   else
      WH(1) = waterfall(axH(1), xdata, ydata, zdata);
      WH(2) = axH(1);
   end

   % labels, again deal with log labels
   xlabel(WH(2), xStr);
   ylabel(WH(2), yStr);
   zlabel(WH(2), 'Spike Count');
   xtl = get_lin_or_log_xlabel(get(WH(2), 'XTick'), xUnits);
   set(WH(2), 'XTickLabel', xtl);
   % set yticks
   WH(2).YTick = ydata;
   if yAtten
      set(WH(2), 'YTickLabel', flipud(get(WH(2), 'YTickLabel')))
   end
end

%------------------------------------------------------------------------
%------------------------------------------------------------------------
% assign output
%------------------------------------------------------------------------
%------------------------------------------------------------------------
if nargout
   varargout{1} = figH;
   varargout{2} = PH;
   varargout{3} = WH;
   varargout{4} = {xdata, ydata, zdata};
end

end   %********** END OF plotFRA FUNCTION ******************

%***********************************************************************
%***********************************************************************
%***********************************************************************
% INTERNAL FUNCTIONS
%***********************************************************************
%***********************************************************************
%***********************************************************************

%------------------------------------------------------------------------
%------------------------------------------------------------------------
% internal function to format tick labels
%------------------------------------------------------------------------
function xtl = get_lin_or_log_xlabel(xt, xUnits)

	xtl = cell(length(xt), 1);

	if strcmpi(xUnits, 'LOG')
		for n = 1:length(xt)
			xtl{n} = sprintf('%.0f', 0.001 * 10^xt(n));
		end
	else
		for n = 1:length(xt)
			xtl{n} = sprintf('%.0f', 0.001 * xt(n));
		end
	end
end
%------------------------------------------------------------------------
%------------------------------------------------------------------------


%------------------------------------------------------------------------
%------------------------------------------------------------------------
function [xdata, ydata, zdata] = ...
             generate_xyzdata(FRA, padFreqVal, padLevelVal, ...
                               interpolateData, interpolateN)
%------------------------------------------------------------------------
%------------------------------------------------------------------------

   %---------------------------------------------------------------------
   % temp vals for script use
   %---------------------------------------------------------------------
   %{
   interpolateData = true;
   interpolateN = 100;
   % need to set pad level and freq
   % level is easy 
   padLevelVal = 90;
   % for freq, need to find next 1/3 octave freq
   fOct = octaves(3, 4000, 110000, 2);
   padFreqVal = fOct(end);
   %}
   %---------------------------------------------------------------------
   % can determine if freq, level are to be padded by status of 
   % padFreqVal and padLevelVal
   %---------------------------------------------------------------------
   if ~isempty(padFreqVal)
      padFreq = true;
   else
      padFreq = false;
   end
   if ~isempty(padLevelVal)
      padLevel = true;
   else
      padLevel = false;
   end
   %---------------------------------------------------------------------
   % set Frequencies
   %---------------------------------------------------------------------
   if padFreq
      Freqs = [FRA.Freqs padFreqVal];
   else
      Freqs = FRA.Freqs;
   end
   %---------------------------------------------------------------------
   % set Levels
   %---------------------------------------------------------------------
   if padLevel
      Levels = [FRA.Levels padLevelVal];
   else
      Levels = FRA.Levels;
   end
   %---------------------------------------------------------------------
   % set MeanCount - this will depend on padding options
   %---------------------------------------------------------------------
   if ~padFreq && ~padLevel
      % no padding, no alterations to FRA.MeanCount
      MeanCount = FRA.MeanCount;

   elseif padFreq && padLevel
      % pad both Freqs (cols) and Levels (rows)
      % first, add a "dummy" freq column to Mean Count 
      MeanCount = [FRA.MeanCount FRA.MeanCount(:, end)];
      % then add a "dummy" level row to MeanCount
      MeanCount = [MeanCount; MeanCount(end, :)];   

   elseif padFreq && ~padLevel
      % no padding of level (rows), just freqs (cols)
      % add a "dummy" freq column to Mean Count 
      MeanCount = [FRA.MeanCount FRA.MeanCount(:, end)];

   elseif ~padFreq && padLevel
      % no padding of Freqs (cols), just Levels (rows)
      % add a "dummy" level row to MeanCount
      MeanCount = [FRA.MeanCount; FRA.MeanCount(end, :)];   

   else
      % degenerate case
      error('WTF????');
   end

   %---------------------------------------------------------------------
   % interpolate points (along freqs)?
   %---------------------------------------------------------------------
   if interpolateData
      % xdata will be "grid" of frequencies
      xdata = linspace(Freqs(1), Freqs(end), interpolateN);
      % assign zdata using sizes of ydata (levels) and xdata (freqs)
      zdata = zeros(length(Levels), length(xdata));
      for l = 1:length(Levels)
         zdata(l, :) = makima(Freqs, MeanCount(l, :), xdata);
      end
   else
      % no interpolation, so just assign Freqs to xdata, MeanCount to zdata.
      % note that these may or may not be padded!
      xdata = Freqs;
      zdata = MeanCount;
   end
   ydata = Levels;

end